{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { Fragment as _Fragment, createVNode as _createVNode } from \"vue\";\nimport { defineComponent, shallowRef, watch, computed, watchEffect } from 'vue';\nimport { qrProps } from './interface';\nimport qrcodegen from './qrcodegen';\nvar ERROR_LEVEL_MAP = {\n  L: qrcodegen.QrCode.Ecc.LOW,\n  M: qrcodegen.QrCode.Ecc.MEDIUM,\n  Q: qrcodegen.QrCode.Ecc.QUARTILE,\n  H: qrcodegen.QrCode.Ecc.HIGH\n};\nvar DEFAULT_SIZE = 128;\nvar DEFAULT_LEVEL = 'L';\nvar DEFAULT_BGCOLOR = '#FFFFFF';\nvar DEFAULT_FGCOLOR = '#000000';\nvar DEFAULT_INCLUDEMARGIN = false;\nvar SPEC_MARGIN_SIZE = 4;\nvar DEFAULT_MARGIN_SIZE = 0;\n// This is *very* rough estimate of max amount of QRCode allowed to be covered.\n// It is \"wrong\" in a lot of ways (area is a terrible way to estimate, it\n// really should be number of modules covered), but if for some reason we don't\n// get an explicit height or width, I'd rather default to something than throw.\nvar DEFAULT_IMG_SCALE = 0.1;\nfunction generatePath(modules) {\n  var margin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var ops = [];\n  modules.forEach(function (row, y) {\n    var start = null;\n    row.forEach(function (cell, x) {\n      if (!cell && start !== null) {\n        // M0 0h7v1H0z injects the space with the move and drops the comma,\n        // saving a char per operation\n        ops.push(\"M\".concat(start + margin, \" \").concat(y + margin, \"h\").concat(x - start, \"v1H\").concat(start + margin, \"z\"));\n        start = null;\n        return;\n      }\n      // end of row, clean up or skip\n      if (x === row.length - 1) {\n        if (!cell) {\n          // We would have closed the op above already so this can only mean\n          // 2+ light modules in a row.\n          return;\n        }\n        if (start === null) {\n          // Just a single dark module.\n          ops.push(\"M\".concat(x + margin, \",\").concat(y + margin, \" h1v1H\").concat(x + margin, \"z\"));\n        } else {\n          // Otherwise finish the current line.\n          ops.push(\"M\".concat(start + margin, \",\").concat(y + margin, \" h\").concat(x + 1 - start, \"v1H\").concat(start + margin, \"z\"));\n        }\n        return;\n      }\n      if (cell && start === null) {\n        start = x;\n      }\n    });\n  });\n  return ops.join('');\n}\n// We could just do this in generatePath, except that we want to support\n// non-Path2D canvas, so we need to keep it an explicit step.\nfunction excavateModules(modules, excavation) {\n  return modules.slice().map(function (row, y) {\n    if (y < excavation.y || y >= excavation.y + excavation.h) {\n      return row;\n    }\n    return row.map(function (cell, x) {\n      if (x < excavation.x || x >= excavation.x + excavation.w) {\n        return cell;\n      }\n      return false;\n    });\n  });\n}\nfunction getImageSettings(cells, size, margin, imageSettings) {\n  if (imageSettings == null) {\n    return null;\n  }\n  var numCells = cells.length + margin * 2;\n  var defaultSize = Math.floor(size * DEFAULT_IMG_SCALE);\n  var scale = numCells / size;\n  var w = (imageSettings.width || defaultSize) * scale;\n  var h = (imageSettings.height || defaultSize) * scale;\n  var x = imageSettings.x == null ? cells.length / 2 - w / 2 : imageSettings.x * scale;\n  var y = imageSettings.y == null ? cells.length / 2 - h / 2 : imageSettings.y * scale;\n  var excavation = null;\n  if (imageSettings.excavate) {\n    var floorX = Math.floor(x);\n    var floorY = Math.floor(y);\n    var ceilW = Math.ceil(w + x - floorX);\n    var ceilH = Math.ceil(h + y - floorY);\n    excavation = {\n      x: floorX,\n      y: floorY,\n      w: ceilW,\n      h: ceilH\n    };\n  }\n  return {\n    x: x,\n    y: y,\n    h: h,\n    w: w,\n    excavation: excavation\n  };\n}\nfunction getMarginSize(includeMargin, marginSize) {\n  if (marginSize != null) {\n    return Math.floor(marginSize);\n  }\n  return includeMargin ? SPEC_MARGIN_SIZE : DEFAULT_MARGIN_SIZE;\n}\n// For canvas we're going to switch our drawing mode based on whether or not\n// the environment supports Path2D. We only need the constructor to be\n// supported, but Edge doesn't actually support the path (string) type\n// argument. Luckily it also doesn't support the addPath() method. We can\n// treat that as the same thing.\nvar SUPPORTS_PATH2D = function () {\n  try {\n    new Path2D().addPath(new Path2D());\n  } catch (e) {\n    return false;\n  }\n  return true;\n}();\nexport var QRCodeCanvas = defineComponent({\n  name: 'QRCodeCanvas',\n  inheritAttrs: false,\n  props: _extends(_extends({}, qrProps()), {\n    level: String,\n    bgColor: String,\n    fgColor: String,\n    marginSize: Number\n  }),\n  setup: function setup(props, _ref) {\n    var attrs = _ref.attrs,\n      expose = _ref.expose;\n    var imgSrc = computed(function () {\n      var _a;\n      return (_a = props.imageSettings) === null || _a === void 0 ? void 0 : _a.src;\n    });\n    var _canvas = shallowRef(null);\n    var _image = shallowRef(null);\n    var isImgLoaded = shallowRef(false);\n    expose({\n      toDataURL: function toDataURL(type, quality) {\n        var _a;\n        return (_a = _canvas.value) === null || _a === void 0 ? void 0 : _a.toDataURL(type, quality);\n      }\n    });\n    watchEffect(function () {\n      var value = props.value,\n        _props$size = props.size,\n        size = _props$size === void 0 ? DEFAULT_SIZE : _props$size,\n        _props$level = props.level,\n        level = _props$level === void 0 ? DEFAULT_LEVEL : _props$level,\n        _props$bgColor = props.bgColor,\n        bgColor = _props$bgColor === void 0 ? DEFAULT_BGCOLOR : _props$bgColor,\n        _props$fgColor = props.fgColor,\n        fgColor = _props$fgColor === void 0 ? DEFAULT_FGCOLOR : _props$fgColor,\n        _props$includeMargin = props.includeMargin,\n        includeMargin = _props$includeMargin === void 0 ? DEFAULT_INCLUDEMARGIN : _props$includeMargin,\n        marginSize = props.marginSize,\n        imageSettings = props.imageSettings;\n      if (_canvas.value != null) {\n        var canvas = _canvas.value;\n        var ctx = canvas.getContext('2d');\n        if (!ctx) {\n          return;\n        }\n        var cells = qrcodegen.QrCode.encodeText(value, ERROR_LEVEL_MAP[level]).getModules();\n        var margin = getMarginSize(includeMargin, marginSize);\n        var numCells = cells.length + margin * 2;\n        var calculatedImageSettings = getImageSettings(cells, size, margin, imageSettings);\n        var image = _image.value;\n        var haveImageToRender = isImgLoaded.value && calculatedImageSettings != null && image !== null && image.complete && image.naturalHeight !== 0 && image.naturalWidth !== 0;\n        if (haveImageToRender) {\n          if (calculatedImageSettings.excavation != null) {\n            cells = excavateModules(cells, calculatedImageSettings.excavation);\n          }\n        }\n        // We're going to scale this so that the number of drawable units\n        // matches the number of cells. This avoids rounding issues, but does\n        // result in some potentially unwanted single pixel issues between\n        // blocks, only in environments that don't support Path2D.\n        var pixelRatio = window.devicePixelRatio || 1;\n        canvas.height = canvas.width = size * pixelRatio;\n        var scale = size / numCells * pixelRatio;\n        ctx.scale(scale, scale);\n        // Draw solid background, only paint dark modules.\n        ctx.fillStyle = bgColor;\n        ctx.fillRect(0, 0, numCells, numCells);\n        ctx.fillStyle = fgColor;\n        if (SUPPORTS_PATH2D) {\n          // $FlowFixMe: Path2D c'tor doesn't support args yet.\n          ctx.fill(new Path2D(generatePath(cells, margin)));\n        } else {\n          cells.forEach(function (row, rdx) {\n            row.forEach(function (cell, cdx) {\n              if (cell) {\n                ctx.fillRect(cdx + margin, rdx + margin, 1, 1);\n              }\n            });\n          });\n        }\n        if (haveImageToRender) {\n          ctx.drawImage(image, calculatedImageSettings.x + margin, calculatedImageSettings.y + margin, calculatedImageSettings.w, calculatedImageSettings.h);\n        }\n      }\n    }, {\n      flush: 'post'\n    });\n    watch(imgSrc, function () {\n      isImgLoaded.value = false;\n    });\n    return function () {\n      var _a;\n      var size = (_a = props.size) !== null && _a !== void 0 ? _a : DEFAULT_SIZE;\n      var canvasStyle = {\n        height: \"\".concat(size, \"px\"),\n        width: \"\".concat(size, \"px\")\n      };\n      var img = null;\n      if (imgSrc.value != null) {\n        img = _createVNode(\"img\", {\n          \"src\": imgSrc.value,\n          \"key\": imgSrc.value,\n          \"style\": {\n            display: 'none'\n          },\n          \"onLoad\": function onLoad() {\n            isImgLoaded.value = true;\n          },\n          \"ref\": _image\n        }, null);\n      }\n      return _createVNode(_Fragment, null, [_createVNode(\"canvas\", _objectSpread(_objectSpread({}, attrs), {}, {\n        \"style\": [canvasStyle, attrs.style],\n        \"ref\": _canvas\n      }), null), img]);\n    };\n  }\n});","map":{"version":3,"names":["_objectSpread","_extends","Fragment","_Fragment","createVNode","_createVNode","defineComponent","shallowRef","watch","computed","watchEffect","qrProps","qrcodegen","ERROR_LEVEL_MAP","L","QrCode","Ecc","LOW","M","MEDIUM","Q","QUARTILE","H","HIGH","DEFAULT_SIZE","DEFAULT_LEVEL","DEFAULT_BGCOLOR","DEFAULT_FGCOLOR","DEFAULT_INCLUDEMARGIN","SPEC_MARGIN_SIZE","DEFAULT_MARGIN_SIZE","DEFAULT_IMG_SCALE","generatePath","modules","margin","arguments","length","undefined","ops","forEach","row","y","start","cell","x","push","concat","join","excavateModules","excavation","slice","map","h","w","getImageSettings","cells","size","imageSettings","numCells","defaultSize","Math","floor","scale","width","height","excavate","floorX","floorY","ceilW","ceil","ceilH","getMarginSize","includeMargin","marginSize","SUPPORTS_PATH2D","Path2D","addPath","e","QRCodeCanvas","name","inheritAttrs","props","level","String","bgColor","fgColor","Number","setup","_ref","attrs","expose","imgSrc","_a","src","_canvas","_image","isImgLoaded","toDataURL","type","quality","value","_props$size","_props$level","_props$bgColor","_props$fgColor","_props$includeMargin","canvas","ctx","getContext","encodeText","getModules","calculatedImageSettings","image","haveImageToRender","complete","naturalHeight","naturalWidth","pixelRatio","window","devicePixelRatio","fillStyle","fillRect","fill","rdx","cdx","drawImage","flush","canvasStyle","img","display","onLoad","style"],"sources":["D:/Desktop/Code/CcAgSearch/ccso-frontend/node_modules/ant-design-vue/es/qrcode/QRCodeCanvas.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { Fragment as _Fragment, createVNode as _createVNode } from \"vue\";\nimport { defineComponent, shallowRef, watch, computed, watchEffect } from 'vue';\nimport { qrProps } from './interface';\nimport qrcodegen from './qrcodegen';\nvar ERROR_LEVEL_MAP = {\n  L: qrcodegen.QrCode.Ecc.LOW,\n  M: qrcodegen.QrCode.Ecc.MEDIUM,\n  Q: qrcodegen.QrCode.Ecc.QUARTILE,\n  H: qrcodegen.QrCode.Ecc.HIGH\n};\nvar DEFAULT_SIZE = 128;\nvar DEFAULT_LEVEL = 'L';\nvar DEFAULT_BGCOLOR = '#FFFFFF';\nvar DEFAULT_FGCOLOR = '#000000';\nvar DEFAULT_INCLUDEMARGIN = false;\nvar SPEC_MARGIN_SIZE = 4;\nvar DEFAULT_MARGIN_SIZE = 0;\n// This is *very* rough estimate of max amount of QRCode allowed to be covered.\n// It is \"wrong\" in a lot of ways (area is a terrible way to estimate, it\n// really should be number of modules covered), but if for some reason we don't\n// get an explicit height or width, I'd rather default to something than throw.\nvar DEFAULT_IMG_SCALE = 0.1;\nfunction generatePath(modules) {\n  var margin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var ops = [];\n  modules.forEach(function (row, y) {\n    var start = null;\n    row.forEach(function (cell, x) {\n      if (!cell && start !== null) {\n        // M0 0h7v1H0z injects the space with the move and drops the comma,\n        // saving a char per operation\n        ops.push(\"M\".concat(start + margin, \" \").concat(y + margin, \"h\").concat(x - start, \"v1H\").concat(start + margin, \"z\"));\n        start = null;\n        return;\n      }\n      // end of row, clean up or skip\n      if (x === row.length - 1) {\n        if (!cell) {\n          // We would have closed the op above already so this can only mean\n          // 2+ light modules in a row.\n          return;\n        }\n        if (start === null) {\n          // Just a single dark module.\n          ops.push(\"M\".concat(x + margin, \",\").concat(y + margin, \" h1v1H\").concat(x + margin, \"z\"));\n        } else {\n          // Otherwise finish the current line.\n          ops.push(\"M\".concat(start + margin, \",\").concat(y + margin, \" h\").concat(x + 1 - start, \"v1H\").concat(start + margin, \"z\"));\n        }\n        return;\n      }\n      if (cell && start === null) {\n        start = x;\n      }\n    });\n  });\n  return ops.join('');\n}\n// We could just do this in generatePath, except that we want to support\n// non-Path2D canvas, so we need to keep it an explicit step.\nfunction excavateModules(modules, excavation) {\n  return modules.slice().map(function (row, y) {\n    if (y < excavation.y || y >= excavation.y + excavation.h) {\n      return row;\n    }\n    return row.map(function (cell, x) {\n      if (x < excavation.x || x >= excavation.x + excavation.w) {\n        return cell;\n      }\n      return false;\n    });\n  });\n}\nfunction getImageSettings(cells, size, margin, imageSettings) {\n  if (imageSettings == null) {\n    return null;\n  }\n  var numCells = cells.length + margin * 2;\n  var defaultSize = Math.floor(size * DEFAULT_IMG_SCALE);\n  var scale = numCells / size;\n  var w = (imageSettings.width || defaultSize) * scale;\n  var h = (imageSettings.height || defaultSize) * scale;\n  var x = imageSettings.x == null ? cells.length / 2 - w / 2 : imageSettings.x * scale;\n  var y = imageSettings.y == null ? cells.length / 2 - h / 2 : imageSettings.y * scale;\n  var excavation = null;\n  if (imageSettings.excavate) {\n    var floorX = Math.floor(x);\n    var floorY = Math.floor(y);\n    var ceilW = Math.ceil(w + x - floorX);\n    var ceilH = Math.ceil(h + y - floorY);\n    excavation = {\n      x: floorX,\n      y: floorY,\n      w: ceilW,\n      h: ceilH\n    };\n  }\n  return {\n    x: x,\n    y: y,\n    h: h,\n    w: w,\n    excavation: excavation\n  };\n}\nfunction getMarginSize(includeMargin, marginSize) {\n  if (marginSize != null) {\n    return Math.floor(marginSize);\n  }\n  return includeMargin ? SPEC_MARGIN_SIZE : DEFAULT_MARGIN_SIZE;\n}\n// For canvas we're going to switch our drawing mode based on whether or not\n// the environment supports Path2D. We only need the constructor to be\n// supported, but Edge doesn't actually support the path (string) type\n// argument. Luckily it also doesn't support the addPath() method. We can\n// treat that as the same thing.\nvar SUPPORTS_PATH2D = function () {\n  try {\n    new Path2D().addPath(new Path2D());\n  } catch (e) {\n    return false;\n  }\n  return true;\n}();\nexport var QRCodeCanvas = defineComponent({\n  name: 'QRCodeCanvas',\n  inheritAttrs: false,\n  props: _extends(_extends({}, qrProps()), {\n    level: String,\n    bgColor: String,\n    fgColor: String,\n    marginSize: Number\n  }),\n  setup: function setup(props, _ref) {\n    var attrs = _ref.attrs,\n      expose = _ref.expose;\n    var imgSrc = computed(function () {\n      var _a;\n      return (_a = props.imageSettings) === null || _a === void 0 ? void 0 : _a.src;\n    });\n    var _canvas = shallowRef(null);\n    var _image = shallowRef(null);\n    var isImgLoaded = shallowRef(false);\n    expose({\n      toDataURL: function toDataURL(type, quality) {\n        var _a;\n        return (_a = _canvas.value) === null || _a === void 0 ? void 0 : _a.toDataURL(type, quality);\n      }\n    });\n    watchEffect(function () {\n      var value = props.value,\n        _props$size = props.size,\n        size = _props$size === void 0 ? DEFAULT_SIZE : _props$size,\n        _props$level = props.level,\n        level = _props$level === void 0 ? DEFAULT_LEVEL : _props$level,\n        _props$bgColor = props.bgColor,\n        bgColor = _props$bgColor === void 0 ? DEFAULT_BGCOLOR : _props$bgColor,\n        _props$fgColor = props.fgColor,\n        fgColor = _props$fgColor === void 0 ? DEFAULT_FGCOLOR : _props$fgColor,\n        _props$includeMargin = props.includeMargin,\n        includeMargin = _props$includeMargin === void 0 ? DEFAULT_INCLUDEMARGIN : _props$includeMargin,\n        marginSize = props.marginSize,\n        imageSettings = props.imageSettings;\n      if (_canvas.value != null) {\n        var canvas = _canvas.value;\n        var ctx = canvas.getContext('2d');\n        if (!ctx) {\n          return;\n        }\n        var cells = qrcodegen.QrCode.encodeText(value, ERROR_LEVEL_MAP[level]).getModules();\n        var margin = getMarginSize(includeMargin, marginSize);\n        var numCells = cells.length + margin * 2;\n        var calculatedImageSettings = getImageSettings(cells, size, margin, imageSettings);\n        var image = _image.value;\n        var haveImageToRender = isImgLoaded.value && calculatedImageSettings != null && image !== null && image.complete && image.naturalHeight !== 0 && image.naturalWidth !== 0;\n        if (haveImageToRender) {\n          if (calculatedImageSettings.excavation != null) {\n            cells = excavateModules(cells, calculatedImageSettings.excavation);\n          }\n        }\n        // We're going to scale this so that the number of drawable units\n        // matches the number of cells. This avoids rounding issues, but does\n        // result in some potentially unwanted single pixel issues between\n        // blocks, only in environments that don't support Path2D.\n        var pixelRatio = window.devicePixelRatio || 1;\n        canvas.height = canvas.width = size * pixelRatio;\n        var scale = size / numCells * pixelRatio;\n        ctx.scale(scale, scale);\n        // Draw solid background, only paint dark modules.\n        ctx.fillStyle = bgColor;\n        ctx.fillRect(0, 0, numCells, numCells);\n        ctx.fillStyle = fgColor;\n        if (SUPPORTS_PATH2D) {\n          // $FlowFixMe: Path2D c'tor doesn't support args yet.\n          ctx.fill(new Path2D(generatePath(cells, margin)));\n        } else {\n          cells.forEach(function (row, rdx) {\n            row.forEach(function (cell, cdx) {\n              if (cell) {\n                ctx.fillRect(cdx + margin, rdx + margin, 1, 1);\n              }\n            });\n          });\n        }\n        if (haveImageToRender) {\n          ctx.drawImage(image, calculatedImageSettings.x + margin, calculatedImageSettings.y + margin, calculatedImageSettings.w, calculatedImageSettings.h);\n        }\n      }\n    }, {\n      flush: 'post'\n    });\n    watch(imgSrc, function () {\n      isImgLoaded.value = false;\n    });\n    return function () {\n      var _a;\n      var size = (_a = props.size) !== null && _a !== void 0 ? _a : DEFAULT_SIZE;\n      var canvasStyle = {\n        height: \"\".concat(size, \"px\"),\n        width: \"\".concat(size, \"px\")\n      };\n      var img = null;\n      if (imgSrc.value != null) {\n        img = _createVNode(\"img\", {\n          \"src\": imgSrc.value,\n          \"key\": imgSrc.value,\n          \"style\": {\n            display: 'none'\n          },\n          \"onLoad\": function onLoad() {\n            isImgLoaded.value = true;\n          },\n          \"ref\": _image\n        }, null);\n      }\n      return _createVNode(_Fragment, null, [_createVNode(\"canvas\", _objectSpread(_objectSpread({}, attrs), {}, {\n        \"style\": [canvasStyle, attrs.style],\n        \"ref\": _canvas\n      }), null), img]);\n    };\n  }\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}