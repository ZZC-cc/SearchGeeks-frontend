{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createVNode as _createVNode } from \"vue\";\nimport { defineComponent, shallowRef, reactive, watch, onMounted, getCurrentInstance, computed, onUnmounted, onUpdated } from 'vue';\nimport classNames from '../_util/classNames';\nimport ResizeObserver from '../vc-resize-observer';\nimport throttleByAnimationFrame from '../_util/throttleByAnimationFrame';\nimport { withInstall } from '../_util/type';\nimport { addObserveTarget, removeObserveTarget, getTargetRect, getFixedTop, getFixedBottom } from './utils';\nimport useConfigInject from '../config-provider/hooks/useConfigInject';\nimport omit from '../_util/omit';\nimport useStyle from './style';\nfunction getDefaultTarget() {\n  return typeof window !== 'undefined' ? window : null;\n}\nvar AffixStatus;\n(function (AffixStatus) {\n  AffixStatus[AffixStatus[\"None\"] = 0] = \"None\";\n  AffixStatus[AffixStatus[\"Prepare\"] = 1] = \"Prepare\";\n})(AffixStatus || (AffixStatus = {}));\n// Affix\nexport var affixProps = function affixProps() {\n  return {\n    /**\n     * 距离窗口顶部达到指定偏移量后触发\n     */\n    offsetTop: Number,\n    /** 距离窗口底部达到指定偏移量后触发 */\n    offsetBottom: Number,\n    /** 设置 Affix 需要监听其滚动事件的元素，值为一个返回对应 DOM 元素的函数 */\n    target: {\n      type: Function,\n      default: getDefaultTarget\n    },\n    prefixCls: String,\n    /** 固定状态改变时触发的回调函数 */\n    onChange: Function,\n    onTestUpdatePosition: Function\n  };\n};\nvar Affix = defineComponent({\n  compatConfig: {\n    MODE: 3\n  },\n  name: 'AAffix',\n  inheritAttrs: false,\n  props: affixProps(),\n  setup: function setup(props, _ref) {\n    var slots = _ref.slots,\n      emit = _ref.emit,\n      expose = _ref.expose,\n      attrs = _ref.attrs;\n    var placeholderNode = shallowRef();\n    var fixedNode = shallowRef();\n    var state = reactive({\n      affixStyle: undefined,\n      placeholderStyle: undefined,\n      status: AffixStatus.None,\n      lastAffix: false,\n      prevTarget: null,\n      timeout: null\n    });\n    var currentInstance = getCurrentInstance();\n    var offsetTop = computed(function () {\n      return props.offsetBottom === undefined && props.offsetTop === undefined ? 0 : props.offsetTop;\n    });\n    var offsetBottom = computed(function () {\n      return props.offsetBottom;\n    });\n    var measure = function measure() {\n      var status = state.status,\n        lastAffix = state.lastAffix;\n      var target = props.target;\n      if (status !== AffixStatus.Prepare || !fixedNode.value || !placeholderNode.value || !target) {\n        return;\n      }\n      var targetNode = target();\n      if (!targetNode) {\n        return;\n      }\n      var newState = {\n        status: AffixStatus.None\n      };\n      var placeholderRect = getTargetRect(placeholderNode.value);\n      if (placeholderRect.top === 0 && placeholderRect.left === 0 && placeholderRect.width === 0 && placeholderRect.height === 0) {\n        return;\n      }\n      var targetRect = getTargetRect(targetNode);\n      var fixedTop = getFixedTop(placeholderRect, targetRect, offsetTop.value);\n      var fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom.value);\n      if (placeholderRect.top === 0 && placeholderRect.left === 0 && placeholderRect.width === 0 && placeholderRect.height === 0) {\n        return;\n      }\n      if (fixedTop !== undefined) {\n        var width = \"\".concat(placeholderRect.width, \"px\");\n        var height = \"\".concat(placeholderRect.height, \"px\");\n        newState.affixStyle = {\n          position: 'fixed',\n          top: fixedTop,\n          width: width,\n          height: height\n        };\n        newState.placeholderStyle = {\n          width: width,\n          height: height\n        };\n      } else if (fixedBottom !== undefined) {\n        var _width = \"\".concat(placeholderRect.width, \"px\");\n        var _height = \"\".concat(placeholderRect.height, \"px\");\n        newState.affixStyle = {\n          position: 'fixed',\n          bottom: fixedBottom,\n          width: _width,\n          height: _height\n        };\n        newState.placeholderStyle = {\n          width: _width,\n          height: _height\n        };\n      }\n      newState.lastAffix = !!newState.affixStyle;\n      if (lastAffix !== newState.lastAffix) {\n        emit('change', newState.lastAffix);\n      }\n      // update state\n      _extends(state, newState);\n    };\n    var prepareMeasure = function prepareMeasure() {\n      _extends(state, {\n        status: AffixStatus.Prepare,\n        affixStyle: undefined,\n        placeholderStyle: undefined\n      });\n      currentInstance.update();\n      // Test if `updatePosition` called\n      if (process.env.NODE_ENV === 'test') {\n        emit('testUpdatePosition');\n      }\n    };\n    var updatePosition = throttleByAnimationFrame(function () {\n      prepareMeasure();\n    });\n    var lazyUpdatePosition = throttleByAnimationFrame(function () {\n      var target = props.target;\n      var affixStyle = state.affixStyle;\n      // Check position change before measure to make Safari smooth\n      if (target && affixStyle) {\n        var targetNode = target();\n        if (targetNode && placeholderNode.value) {\n          var targetRect = getTargetRect(targetNode);\n          var placeholderRect = getTargetRect(placeholderNode.value);\n          var fixedTop = getFixedTop(placeholderRect, targetRect, offsetTop.value);\n          var fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom.value);\n          if (fixedTop !== undefined && affixStyle.top === fixedTop || fixedBottom !== undefined && affixStyle.bottom === fixedBottom) {\n            return;\n          }\n        }\n      }\n      // Directly call prepare measure since it's already throttled.\n      prepareMeasure();\n    });\n    expose({\n      updatePosition: updatePosition,\n      lazyUpdatePosition: lazyUpdatePosition\n    });\n    watch(function () {\n      return props.target;\n    }, function (val) {\n      var newTarget = (val === null || val === void 0 ? void 0 : val()) || null;\n      if (state.prevTarget !== newTarget) {\n        removeObserveTarget(currentInstance);\n        if (newTarget) {\n          addObserveTarget(newTarget, currentInstance);\n          // Mock Event object.\n          updatePosition();\n        }\n        state.prevTarget = newTarget;\n      }\n    });\n    watch(function () {\n      return [props.offsetTop, props.offsetBottom];\n    }, updatePosition);\n    onMounted(function () {\n      var target = props.target;\n      if (target) {\n        // [Legacy] Wait for parent component ref has its value.\n        // We should use target as directly element instead of function which makes element check hard.\n        state.timeout = setTimeout(function () {\n          addObserveTarget(target(), currentInstance);\n          // Mock Event object.\n          updatePosition();\n        });\n      }\n    });\n    onUpdated(function () {\n      measure();\n    });\n    onUnmounted(function () {\n      clearTimeout(state.timeout);\n      removeObserveTarget(currentInstance);\n      updatePosition.cancel();\n      // https://github.com/ant-design/ant-design/issues/22683\n      lazyUpdatePosition.cancel();\n    });\n    var _useConfigInject = useConfigInject('affix', props),\n      prefixCls = _useConfigInject.prefixCls;\n    var _useStyle = useStyle(prefixCls),\n      _useStyle2 = _slicedToArray(_useStyle, 2),\n      wrapSSR = _useStyle2[0],\n      hashId = _useStyle2[1];\n    return function () {\n      var _classNames;\n      var _a;\n      var affixStyle = state.affixStyle,\n        placeholderStyle = state.placeholderStyle;\n      var className = classNames((_classNames = {}, _defineProperty(_classNames, prefixCls.value, affixStyle), _defineProperty(_classNames, hashId.value, true), _classNames));\n      var restProps = omit(props, ['prefixCls', 'offsetTop', 'offsetBottom', 'target', 'onChange', 'onTestUpdatePosition']);\n      return wrapSSR(_createVNode(ResizeObserver, {\n        \"onResize\": updatePosition\n      }, {\n        default: function _default() {\n          return [_createVNode(\"div\", _objectSpread(_objectSpread(_objectSpread({}, restProps), attrs), {}, {\n            \"ref\": placeholderNode\n          }), [affixStyle && _createVNode(\"div\", {\n            \"style\": placeholderStyle,\n            \"aria-hidden\": \"true\"\n          }, null), _createVNode(\"div\", {\n            \"class\": className,\n            \"ref\": fixedNode,\n            \"style\": affixStyle\n          }, [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)])])];\n        }\n      }));\n    };\n  }\n});\nexport default withInstall(Affix);","map":{"version":3,"names":["_objectSpread","_defineProperty","_slicedToArray","_extends","createVNode","_createVNode","defineComponent","shallowRef","reactive","watch","onMounted","getCurrentInstance","computed","onUnmounted","onUpdated","classNames","ResizeObserver","throttleByAnimationFrame","withInstall","addObserveTarget","removeObserveTarget","getTargetRect","getFixedTop","getFixedBottom","useConfigInject","omit","useStyle","getDefaultTarget","window","AffixStatus","affixProps","offsetTop","Number","offsetBottom","target","type","Function","default","prefixCls","String","onChange","onTestUpdatePosition","Affix","compatConfig","MODE","name","inheritAttrs","props","setup","_ref","slots","emit","expose","attrs","placeholderNode","fixedNode","state","affixStyle","undefined","placeholderStyle","status","None","lastAffix","prevTarget","timeout","currentInstance","measure","Prepare","value","targetNode","newState","placeholderRect","top","left","width","height","targetRect","fixedTop","fixedBottom","concat","position","_width","_height","bottom","prepareMeasure","update","process","env","NODE_ENV","updatePosition","lazyUpdatePosition","val","newTarget","setTimeout","clearTimeout","cancel","_useConfigInject","_useStyle","_useStyle2","wrapSSR","hashId","_classNames","_a","className","restProps","_default","call"],"sources":["D:/Desktop/CcAgSearch/ccso-frontend/node_modules/ant-design-vue/es/affix/index.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createVNode as _createVNode } from \"vue\";\nimport { defineComponent, shallowRef, reactive, watch, onMounted, getCurrentInstance, computed, onUnmounted, onUpdated } from 'vue';\nimport classNames from '../_util/classNames';\nimport ResizeObserver from '../vc-resize-observer';\nimport throttleByAnimationFrame from '../_util/throttleByAnimationFrame';\nimport { withInstall } from '../_util/type';\nimport { addObserveTarget, removeObserveTarget, getTargetRect, getFixedTop, getFixedBottom } from './utils';\nimport useConfigInject from '../config-provider/hooks/useConfigInject';\nimport omit from '../_util/omit';\nimport useStyle from './style';\nfunction getDefaultTarget() {\n  return typeof window !== 'undefined' ? window : null;\n}\nvar AffixStatus;\n(function (AffixStatus) {\n  AffixStatus[AffixStatus[\"None\"] = 0] = \"None\";\n  AffixStatus[AffixStatus[\"Prepare\"] = 1] = \"Prepare\";\n})(AffixStatus || (AffixStatus = {}));\n// Affix\nexport var affixProps = function affixProps() {\n  return {\n    /**\n     * 距离窗口顶部达到指定偏移量后触发\n     */\n    offsetTop: Number,\n    /** 距离窗口底部达到指定偏移量后触发 */\n    offsetBottom: Number,\n    /** 设置 Affix 需要监听其滚动事件的元素，值为一个返回对应 DOM 元素的函数 */\n    target: {\n      type: Function,\n      default: getDefaultTarget\n    },\n    prefixCls: String,\n    /** 固定状态改变时触发的回调函数 */\n    onChange: Function,\n    onTestUpdatePosition: Function\n  };\n};\nvar Affix = defineComponent({\n  compatConfig: {\n    MODE: 3\n  },\n  name: 'AAffix',\n  inheritAttrs: false,\n  props: affixProps(),\n  setup: function setup(props, _ref) {\n    var slots = _ref.slots,\n      emit = _ref.emit,\n      expose = _ref.expose,\n      attrs = _ref.attrs;\n    var placeholderNode = shallowRef();\n    var fixedNode = shallowRef();\n    var state = reactive({\n      affixStyle: undefined,\n      placeholderStyle: undefined,\n      status: AffixStatus.None,\n      lastAffix: false,\n      prevTarget: null,\n      timeout: null\n    });\n    var currentInstance = getCurrentInstance();\n    var offsetTop = computed(function () {\n      return props.offsetBottom === undefined && props.offsetTop === undefined ? 0 : props.offsetTop;\n    });\n    var offsetBottom = computed(function () {\n      return props.offsetBottom;\n    });\n    var measure = function measure() {\n      var status = state.status,\n        lastAffix = state.lastAffix;\n      var target = props.target;\n      if (status !== AffixStatus.Prepare || !fixedNode.value || !placeholderNode.value || !target) {\n        return;\n      }\n      var targetNode = target();\n      if (!targetNode) {\n        return;\n      }\n      var newState = {\n        status: AffixStatus.None\n      };\n      var placeholderRect = getTargetRect(placeholderNode.value);\n      if (placeholderRect.top === 0 && placeholderRect.left === 0 && placeholderRect.width === 0 && placeholderRect.height === 0) {\n        return;\n      }\n      var targetRect = getTargetRect(targetNode);\n      var fixedTop = getFixedTop(placeholderRect, targetRect, offsetTop.value);\n      var fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom.value);\n      if (placeholderRect.top === 0 && placeholderRect.left === 0 && placeholderRect.width === 0 && placeholderRect.height === 0) {\n        return;\n      }\n      if (fixedTop !== undefined) {\n        var width = \"\".concat(placeholderRect.width, \"px\");\n        var height = \"\".concat(placeholderRect.height, \"px\");\n        newState.affixStyle = {\n          position: 'fixed',\n          top: fixedTop,\n          width: width,\n          height: height\n        };\n        newState.placeholderStyle = {\n          width: width,\n          height: height\n        };\n      } else if (fixedBottom !== undefined) {\n        var _width = \"\".concat(placeholderRect.width, \"px\");\n        var _height = \"\".concat(placeholderRect.height, \"px\");\n        newState.affixStyle = {\n          position: 'fixed',\n          bottom: fixedBottom,\n          width: _width,\n          height: _height\n        };\n        newState.placeholderStyle = {\n          width: _width,\n          height: _height\n        };\n      }\n      newState.lastAffix = !!newState.affixStyle;\n      if (lastAffix !== newState.lastAffix) {\n        emit('change', newState.lastAffix);\n      }\n      // update state\n      _extends(state, newState);\n    };\n    var prepareMeasure = function prepareMeasure() {\n      _extends(state, {\n        status: AffixStatus.Prepare,\n        affixStyle: undefined,\n        placeholderStyle: undefined\n      });\n      currentInstance.update();\n      // Test if `updatePosition` called\n      if (process.env.NODE_ENV === 'test') {\n        emit('testUpdatePosition');\n      }\n    };\n    var updatePosition = throttleByAnimationFrame(function () {\n      prepareMeasure();\n    });\n    var lazyUpdatePosition = throttleByAnimationFrame(function () {\n      var target = props.target;\n      var affixStyle = state.affixStyle;\n      // Check position change before measure to make Safari smooth\n      if (target && affixStyle) {\n        var targetNode = target();\n        if (targetNode && placeholderNode.value) {\n          var targetRect = getTargetRect(targetNode);\n          var placeholderRect = getTargetRect(placeholderNode.value);\n          var fixedTop = getFixedTop(placeholderRect, targetRect, offsetTop.value);\n          var fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom.value);\n          if (fixedTop !== undefined && affixStyle.top === fixedTop || fixedBottom !== undefined && affixStyle.bottom === fixedBottom) {\n            return;\n          }\n        }\n      }\n      // Directly call prepare measure since it's already throttled.\n      prepareMeasure();\n    });\n    expose({\n      updatePosition: updatePosition,\n      lazyUpdatePosition: lazyUpdatePosition\n    });\n    watch(function () {\n      return props.target;\n    }, function (val) {\n      var newTarget = (val === null || val === void 0 ? void 0 : val()) || null;\n      if (state.prevTarget !== newTarget) {\n        removeObserveTarget(currentInstance);\n        if (newTarget) {\n          addObserveTarget(newTarget, currentInstance);\n          // Mock Event object.\n          updatePosition();\n        }\n        state.prevTarget = newTarget;\n      }\n    });\n    watch(function () {\n      return [props.offsetTop, props.offsetBottom];\n    }, updatePosition);\n    onMounted(function () {\n      var target = props.target;\n      if (target) {\n        // [Legacy] Wait for parent component ref has its value.\n        // We should use target as directly element instead of function which makes element check hard.\n        state.timeout = setTimeout(function () {\n          addObserveTarget(target(), currentInstance);\n          // Mock Event object.\n          updatePosition();\n        });\n      }\n    });\n    onUpdated(function () {\n      measure();\n    });\n    onUnmounted(function () {\n      clearTimeout(state.timeout);\n      removeObserveTarget(currentInstance);\n      updatePosition.cancel();\n      // https://github.com/ant-design/ant-design/issues/22683\n      lazyUpdatePosition.cancel();\n    });\n    var _useConfigInject = useConfigInject('affix', props),\n      prefixCls = _useConfigInject.prefixCls;\n    var _useStyle = useStyle(prefixCls),\n      _useStyle2 = _slicedToArray(_useStyle, 2),\n      wrapSSR = _useStyle2[0],\n      hashId = _useStyle2[1];\n    return function () {\n      var _classNames;\n      var _a;\n      var affixStyle = state.affixStyle,\n        placeholderStyle = state.placeholderStyle;\n      var className = classNames((_classNames = {}, _defineProperty(_classNames, prefixCls.value, affixStyle), _defineProperty(_classNames, hashId.value, true), _classNames));\n      var restProps = omit(props, ['prefixCls', 'offsetTop', 'offsetBottom', 'target', 'onChange', 'onTestUpdatePosition']);\n      return wrapSSR(_createVNode(ResizeObserver, {\n        \"onResize\": updatePosition\n      }, {\n        default: function _default() {\n          return [_createVNode(\"div\", _objectSpread(_objectSpread(_objectSpread({}, restProps), attrs), {}, {\n            \"ref\": placeholderNode\n          }), [affixStyle && _createVNode(\"div\", {\n            \"style\": placeholderStyle,\n            \"aria-hidden\": \"true\"\n          }, null), _createVNode(\"div\", {\n            \"class\": className,\n            \"ref\": fixedNode,\n            \"style\": affixStyle\n          }, [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)])])];\n        }\n      }));\n    };\n  }\n});\nexport default withInstall(Affix);"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}