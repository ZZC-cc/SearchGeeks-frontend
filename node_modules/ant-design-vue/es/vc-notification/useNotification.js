import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _extends from "@babel/runtime/helpers/esm/extends";
import { createVNode as _createVNode } from "vue";
var __rest = this && this.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
import { shallowRef, watch, computed } from 'vue';
import HookNotification, { getUuid } from './HookNotification';
var defaultGetContainer = function defaultGetContainer() {
  return document.body;
};
var uniqueKey = 0;
function mergeConfig() {
  var clone = {};
  for (var _len = arguments.length, objList = new Array(_len), _key = 0; _key < _len; _key++) {
    objList[_key] = arguments[_key];
  }
  objList.forEach(function (obj) {
    if (obj) {
      Object.keys(obj).forEach(function (key) {
        var val = obj[key];
        if (val !== undefined) {
          clone[key] = val;
        }
      });
    }
  });
  return clone;
}
export default function useNotification() {
  var rootConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var _rootConfig$getContai = rootConfig.getContainer,
    getContainer = _rootConfig$getContai === void 0 ? defaultGetContainer : _rootConfig$getContai,
    motion = rootConfig.motion,
    prefixCls = rootConfig.prefixCls,
    maxCount = rootConfig.maxCount,
    getClassName = rootConfig.getClassName,
    getStyles = rootConfig.getStyles,
    onAllRemoved = rootConfig.onAllRemoved,
    shareConfig = __rest(rootConfig, ["getContainer", "motion", "prefixCls", "maxCount", "getClassName", "getStyles", "onAllRemoved"]);
  var notices = shallowRef([]);
  var notificationsRef = shallowRef();
  var add = function add(originNotice, holderCallback) {
    var key = originNotice.key || getUuid();
    var notice = _extends(_extends({}, originNotice), {
      key: key
    });
    var noticeIndex = notices.value.map(function (v) {
      return v.notice.key;
    }).indexOf(key);
    var updatedNotices = notices.value.concat();
    if (noticeIndex !== -1) {
      updatedNotices.splice(noticeIndex, 1, {
        notice: notice,
        holderCallback: holderCallback
      });
    } else {
      if (maxCount && notices.value.length >= maxCount) {
        notice.key = updatedNotices[0].notice.key;
        notice.updateMark = getUuid();
        notice.userPassKey = key;
        updatedNotices.shift();
      }
      updatedNotices.push({
        notice: notice,
        holderCallback: holderCallback
      });
    }
    notices.value = updatedNotices;
  };
  var removeNotice = function removeNotice(removeKey) {
    notices.value = notices.value.filter(function (_ref) {
      var _ref$notice = _ref.notice,
        key = _ref$notice.key,
        userPassKey = _ref$notice.userPassKey;
      var mergedKey = userPassKey || key;
      return mergedKey !== removeKey;
    });
  };
  var destroy = function destroy() {
    notices.value = [];
  };
  var contextHolder = computed(function () {
    return _createVNode(HookNotification, {
      "ref": notificationsRef,
      "prefixCls": prefixCls,
      "maxCount": maxCount,
      "notices": notices.value,
      "remove": removeNotice,
      "getClassName": getClassName,
      "getStyles": getStyles,
      "animation": motion,
      "hashId": rootConfig.hashId,
      "onAllRemoved": onAllRemoved,
      "getContainer": getContainer
    }, null);
  });
  var taskQueue = shallowRef([]);
  // ========================= Refs =========================
  var api = {
    open: function open(config) {
      var mergedConfig = mergeConfig(shareConfig, config);
      //@ts-ignore
      if (mergedConfig.key === null || mergedConfig.key === undefined) {
        //@ts-ignore
        mergedConfig.key = "vc-notification-".concat(uniqueKey);
        uniqueKey += 1;
      }
      taskQueue.value = [].concat(_toConsumableArray(taskQueue.value), [{
        type: 'open',
        config: mergedConfig
      }]);
    },
    close: function close(key) {
      taskQueue.value = [].concat(_toConsumableArray(taskQueue.value), [{
        type: 'close',
        key: key
      }]);
    },
    destroy: function destroy() {
      taskQueue.value = [].concat(_toConsumableArray(taskQueue.value), [{
        type: 'destroy'
      }]);
    }
  };
  // ======================== Effect ========================
  watch(taskQueue, function () {
    // Flush task when node ready
    if (taskQueue.value.length) {
      taskQueue.value.forEach(function (task) {
        switch (task.type) {
          case 'open':
            // @ts-ignore
            add(task.config);
            break;
          case 'close':
            removeNotice(task.key);
            break;
          case 'destroy':
            destroy();
            break;
        }
      });
      taskQueue.value = [];
    }
  });
  // ======================== Return ========================
  return [api, function () {
    return contextHolder.value;
  }];
}