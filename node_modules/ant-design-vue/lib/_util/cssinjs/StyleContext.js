"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StyleProvider = exports.CSS_IN_JS_INSTANCE_ID = exports.CSS_IN_JS_INSTANCE = exports.ATTR_TOKEN = exports.ATTR_MARK = exports.ATTR_DEV_CACHE_PATH = void 0;
exports.createCache = createCache;
exports.useStyleProvider = exports.useStyleInject = exports.styleProviderProps = exports.default = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _vue = require("vue");
var _Cache = _interopRequireDefault(require("./Cache"));
var _type = require("../type");
var _initDefaultProps = _interopRequireDefault(require("../props-util/initDefaultProps"));
var ATTR_TOKEN = 'data-token-hash';
exports.ATTR_TOKEN = ATTR_TOKEN;
var ATTR_MARK = 'data-css-hash';
exports.ATTR_MARK = ATTR_MARK;
var ATTR_DEV_CACHE_PATH = 'data-dev-cache-path';
// Mark css-in-js instance in style element
exports.ATTR_DEV_CACHE_PATH = ATTR_DEV_CACHE_PATH;
var CSS_IN_JS_INSTANCE = '__cssinjs_instance__';
exports.CSS_IN_JS_INSTANCE = CSS_IN_JS_INSTANCE;
var CSS_IN_JS_INSTANCE_ID = Math.random().toString(12).slice(2);
exports.CSS_IN_JS_INSTANCE_ID = CSS_IN_JS_INSTANCE_ID;
function createCache() {
  if (typeof document !== 'undefined' && document.head && document.body) {
    var styles = document.body.querySelectorAll("style[".concat(ATTR_MARK, "]")) || [];
    var firstChild = document.head.firstChild;
    Array.from(styles).forEach(function (style) {
      style[CSS_IN_JS_INSTANCE] = style[CSS_IN_JS_INSTANCE] || CSS_IN_JS_INSTANCE_ID;
      // Not force move if no head
      document.head.insertBefore(style, firstChild);
    });
    // Deduplicate of moved styles
    var styleHash = {};
    Array.from(document.querySelectorAll("style[".concat(ATTR_MARK, "]"))).forEach(function (style) {
      var _a;
      var hash = style.getAttribute(ATTR_MARK);
      if (styleHash[hash]) {
        if (style[CSS_IN_JS_INSTANCE] === CSS_IN_JS_INSTANCE_ID) {
          (_a = style.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(style);
        }
      } else {
        styleHash[hash] = true;
      }
    });
  }
  return new _Cache.default();
}
var StyleContextKey = Symbol('StyleContextKey');
var defaultStyleContext = {
  cache: createCache(),
  defaultCache: true,
  hashPriority: 'low'
};
var useStyleInject = function useStyleInject() {
  return (0, _vue.inject)(StyleContextKey, (0, _vue.shallowRef)((0, _extends2.default)({}, defaultStyleContext)));
};
exports.useStyleInject = useStyleInject;
var useStyleProvider = function useStyleProvider(props) {
  var parentContext = useStyleInject();
  var context = (0, _vue.shallowRef)((0, _extends2.default)({}, defaultStyleContext));
  (0, _vue.watch)([props, parentContext], function () {
    var mergedContext = (0, _extends2.default)({}, parentContext.value);
    var propsValue = (0, _vue.unref)(props);
    Object.keys(propsValue).forEach(function (key) {
      var value = propsValue[key];
      if (propsValue[key] !== undefined) {
        mergedContext[key] = value;
      }
    });
    var cache = propsValue.cache;
    mergedContext.cache = mergedContext.cache || createCache();
    mergedContext.defaultCache = !cache && parentContext.value.defaultCache;
    context.value = mergedContext;
  }, {
    immediate: true
  });
  (0, _vue.provide)(StyleContextKey, context);
  return context;
};
exports.useStyleProvider = useStyleProvider;
var styleProviderProps = function styleProviderProps() {
  return {
    autoClear: (0, _type.booleanType)(),
    /** @private Test only. Not work in production. */
    mock: (0, _type.stringType)(),
    /**
     * Only set when you need ssr to extract style on you own.
     * If not provided, it will auto create <style /> on the end of Provider in server side.
     */
    cache: (0, _type.objectType)(),
    /** Tell children that this context is default generated context */
    defaultCache: (0, _type.booleanType)(),
    /** Use `:where` selector to reduce hashId css selector priority */
    hashPriority: (0, _type.stringType)(),
    /** Tell cssinjs where to inject style in */
    container: (0, _type.someType)(),
    /** Component wil render inline  `<style />` for fallback in SSR. Not recommend. */
    ssrInline: (0, _type.booleanType)(),
    /** Transform css before inject in document. Please note that `transformers` do not support dynamic update */
    transformers: (0, _type.arrayType)(),
    /**
     * Linters to lint css before inject in document.
     * Styles will be linted after transforming.
     * Please note that `linters` do not support dynamic update.
     */
    linters: (0, _type.arrayType)()
  };
};
exports.styleProviderProps = styleProviderProps;
var StyleProvider = (0, _type.withInstall)((0, _vue.defineComponent)({
  name: 'AStyleProvider',
  inheritAttrs: false,
  props: (0, _initDefaultProps.default)(styleProviderProps(), defaultStyleContext),
  setup: function setup(props, _ref) {
    var slots = _ref.slots;
    useStyleProvider(props);
    return function () {
      var _a;
      return (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots);
    };
  }
}));
exports.StyleProvider = StyleProvider;
var _default = {
  useStyleInject: useStyleInject,
  useStyleProvider: useStyleProvider,
  StyleProvider: StyleProvider
};
exports.default = _default;