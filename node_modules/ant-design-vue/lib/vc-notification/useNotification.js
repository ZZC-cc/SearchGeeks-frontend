"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = useNotification;
var _vue = require("vue");
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _HookNotification = _interopRequireWildcard(require("./HookNotification"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var __rest = void 0 && (void 0).__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var defaultGetContainer = function defaultGetContainer() {
  return document.body;
};
var uniqueKey = 0;
function mergeConfig() {
  var clone = {};
  for (var _len = arguments.length, objList = new Array(_len), _key = 0; _key < _len; _key++) {
    objList[_key] = arguments[_key];
  }
  objList.forEach(function (obj) {
    if (obj) {
      Object.keys(obj).forEach(function (key) {
        var val = obj[key];
        if (val !== undefined) {
          clone[key] = val;
        }
      });
    }
  });
  return clone;
}
function useNotification() {
  var rootConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var _rootConfig$getContai = rootConfig.getContainer,
    getContainer = _rootConfig$getContai === void 0 ? defaultGetContainer : _rootConfig$getContai,
    motion = rootConfig.motion,
    prefixCls = rootConfig.prefixCls,
    maxCount = rootConfig.maxCount,
    getClassName = rootConfig.getClassName,
    getStyles = rootConfig.getStyles,
    onAllRemoved = rootConfig.onAllRemoved,
    shareConfig = __rest(rootConfig, ["getContainer", "motion", "prefixCls", "maxCount", "getClassName", "getStyles", "onAllRemoved"]);
  var notices = (0, _vue.shallowRef)([]);
  var notificationsRef = (0, _vue.shallowRef)();
  var add = function add(originNotice, holderCallback) {
    var key = originNotice.key || (0, _HookNotification.getUuid)();
    var notice = (0, _extends2.default)((0, _extends2.default)({}, originNotice), {
      key: key
    });
    var noticeIndex = notices.value.map(function (v) {
      return v.notice.key;
    }).indexOf(key);
    var updatedNotices = notices.value.concat();
    if (noticeIndex !== -1) {
      updatedNotices.splice(noticeIndex, 1, {
        notice: notice,
        holderCallback: holderCallback
      });
    } else {
      if (maxCount && notices.value.length >= maxCount) {
        notice.key = updatedNotices[0].notice.key;
        notice.updateMark = (0, _HookNotification.getUuid)();
        notice.userPassKey = key;
        updatedNotices.shift();
      }
      updatedNotices.push({
        notice: notice,
        holderCallback: holderCallback
      });
    }
    notices.value = updatedNotices;
  };
  var removeNotice = function removeNotice(removeKey) {
    notices.value = notices.value.filter(function (_ref) {
      var _ref$notice = _ref.notice,
        key = _ref$notice.key,
        userPassKey = _ref$notice.userPassKey;
      var mergedKey = userPassKey || key;
      return mergedKey !== removeKey;
    });
  };
  var destroy = function destroy() {
    notices.value = [];
  };
  var contextHolder = (0, _vue.computed)(function () {
    return (0, _vue.createVNode)(_HookNotification.default, {
      "ref": notificationsRef,
      "prefixCls": prefixCls,
      "maxCount": maxCount,
      "notices": notices.value,
      "remove": removeNotice,
      "getClassName": getClassName,
      "getStyles": getStyles,
      "animation": motion,
      "hashId": rootConfig.hashId,
      "onAllRemoved": onAllRemoved,
      "getContainer": getContainer
    }, null);
  });
  var taskQueue = (0, _vue.shallowRef)([]);
  // ========================= Refs =========================
  var api = {
    open: function open(config) {
      var mergedConfig = mergeConfig(shareConfig, config);
      //@ts-ignore
      if (mergedConfig.key === null || mergedConfig.key === undefined) {
        //@ts-ignore
        mergedConfig.key = "vc-notification-".concat(uniqueKey);
        uniqueKey += 1;
      }
      taskQueue.value = [].concat((0, _toConsumableArray2.default)(taskQueue.value), [{
        type: 'open',
        config: mergedConfig
      }]);
    },
    close: function close(key) {
      taskQueue.value = [].concat((0, _toConsumableArray2.default)(taskQueue.value), [{
        type: 'close',
        key: key
      }]);
    },
    destroy: function destroy() {
      taskQueue.value = [].concat((0, _toConsumableArray2.default)(taskQueue.value), [{
        type: 'destroy'
      }]);
    }
  };
  // ======================== Effect ========================
  (0, _vue.watch)(taskQueue, function () {
    // Flush task when node ready
    if (taskQueue.value.length) {
      taskQueue.value.forEach(function (task) {
        switch (task.type) {
          case 'open':
            // @ts-ignore
            add(task.config);
            break;
          case 'close':
            removeNotice(task.key);
            break;
          case 'destroy':
            destroy();
            break;
        }
      });
      taskQueue.value = [];
    }
  });
  // ======================== Return ========================
  return [api, function () {
    return contextHolder.value;
  }];
}